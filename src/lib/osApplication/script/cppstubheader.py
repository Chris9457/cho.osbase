import os.path

import yaml
from apilex import ApiTypes as types
from apilex import ApiTags as tags
from apilex import ApiAccess
from cppbase import CppBase
from cppexception import CppException


class CppStubHeader(CppBase):

    def __init__(self, yamlApi, headerFile, apiFile):
        super().__init__(yamlApi, headerFile, apiFile)

    def __addHeader(self):
        if self.hasField(self.yamlApi, tags.serviceTag):
            serviceModule = self.yamlApi[tags.serviceTag]
        else:
            serviceModule = self.yamlApi[tags.moduleTag]

        if self.hasField(serviceModule, tags.descriptionTag):
            self.file.write('// \\brief ' + serviceModule[tags.descriptionTag] + '\n')

        self.addAutoGeneratedHeader()
        self.file.write('#pragma once\n')

    def __addIncludes(self):
        self.file.write('#include "osApplication/IService.h"\n')
        self.file.write('#include "osApplication/ServiceException.h"\n')
        self.file.write('#include "osApplication/TaskLoop.h"\n')
        self.file.write('#include "osCore/Serialization/CoreKeySerializer.h"\n')
        self.file.write('#include "osCore/Serialization/Serializer.h"\n')
        self.file.write('#include "osData/AsyncData.h"\n')

        # check for uri types
        uriFound = False
        if tags.domainObjectsTag in self.yamlApi:
            for domainObject in self.yamlApi[tags.domainObjectsTag]:
                if uriFound:
                    break
                if tags.fieldsTag in domainObject:
                    for field in domainObject[tags.fieldsTag]:
                        uriFound = tags.typeTag in field and field[tags.typeTag] == types.uriType
                        if uriFound:
                            break

            if not uriFound and tags.processTag in self.yamlApi:
                for process in self.yamlApi[tags.processTag]:
                    if uriFound:
                        break
                    if tags.fieldsTag in domainObject:
                        for field in domainObject[tags.fieldsTag]:
                            uriFound = tags.typeTag in field and field[tags.typeTag] == types.uriType
                            if uriFound:
                                break

        if uriFound:
            self.file.write('#include "osData/Uri.h"\n')
        self.file.write('\n')

    def __addImports(self):
        if not self.hasField(self.yamlApi, tags.importsTag):
            return

        self.file.write('#pragma region import section\n')

        saveApiFiles = self.apiFile.copy()
        for importEntry in self.yamlApi[tags.importsTag]:
            if tags.nameTag not in importEntry:
                raise CppException('CppStubHeader.__addImports', 'Expecting "' + tags.nameTag + '" instead of "' +
                                   importEntry)
            importFile = importEntry[tags.nameTag]
            if not os.path.exists(importFile):
                importFile = os.path.abspath(os.path.join(os.path.dirname(self.apiFile[-1]), importFile))

            if not os.path.exists(importFile):
                raise CppException('CppStubHeader.__addImports', 'The file "' + importEntry[tags.nameTag] +
                                   '" doesn\'t exist')

            if importFile in self.apiFile:
                continue

            self.apiFile.append(importFile)
            with open(importFile, 'r') as stream:
                yamlImport = yaml.safe_load(stream)

            moduleFileName = os.path.basename(importFile)
            moduleFileName = os.path.splitext(moduleFileName)[0] + '.h'
            moduleFileName = os.path.join(os.path.dirname(self.file.name), moduleFileName)
            try:
                os.makedirs(os.path.dirname(moduleFileName), exist_ok=True)
                moduleFile = open(moduleFileName, 'w')
            except FileNotFoundError:
                raise CppException('CppStubHeader.__imports', 'Can not create file: ' + moduleFileName)

            module = CppStubHeader(yamlImport, moduleFile, self.apiFile)
            module.generate()

        self.apiFile = saveApiFiles.copy()

        self.file.write('#include "' + os.path.basename(moduleFileName) + '"\n')
        self.file.write('#pragma endregion\n\n')

    def __addConstants(self):
        if self.hasField(self.yamlApi, tags.moduleTag):
            return

        if not self.hasField(self.yamlApi[tags.serviceTag], tags.constantsTag):
            return

        self.file.write('    // Constants\n\n')

        for constant in self.yamlApi[tags.serviceTag][tags.constantsTag]:
            self.file.write('    const std::string ' + constant[tags.nameTag] + ' = "' + constant[tags.valueTag] + '";')
            if self.hasField(constant, tags.descriptionTag):
                self.file.write(' //!< ' + constant[tags.descriptionTag])

            self.file.write('\n')

        self.file.write('\n')

    def __addStruct(self, struct):
        if self.hasField(struct, tags.descriptionTag):
            self.file.write('    /**\n')
            self.file.write('     * \\brief ' + struct[tags.descriptionTag] + '\n')
            self.file.write('     */\n')

        name = struct[tags.structTag]
        self.file.write('    struct ' + name + ' {\n')

        fieldNames = []
        if self.hasField(struct, tags.fieldsTag):
            for field in struct[tags.fieldsTag]:
                fieldType = self.getCppType(field[tags.typeTag])
                if type is None:
                    return

                fieldName = field[tags.nameTag]
                fieldNames.append(fieldName)
                self.file.write('        ' + fieldType + ' ' + fieldName)
                if self.hasField(field, tags.valueTag):
                    fieldValue = field[tags.valueTag]
                    if type(fieldValue) is str:
                        strFieldValue = fieldValue
                    else:
                        strFieldValue = str(fieldValue)

                    if field[tags.typeTag] == types.stringType:
                        self.file.write(' = "' + strFieldValue + '"')
                    else:
                        self.file.write(' = ' + strFieldValue)
                self.file.write(';')
                if tags.descriptionTag in field:
                    self.file.write(' //!< ' + field[tags.descriptionTag])
                self.file.write('\n')

        self.file.write('    };\n')
        self.file.write('\n')

    def __addEnum(self, enum):
        if self.hasField(enum, tags.descriptionTag):
            self.file.write('    /**\n')
            self.file.write('     * \\brief ' + enum[tags.descriptionTag] + '\n')
            self.file.write('     */\n')

        name = enum[tags.enumTag]

        self.file.write('    enum class ' + name + ' {\n')

        if self.hasField(enum, tags.valuesTag):
            for value in enum[tags.valuesTag]:
                self.file.write('        ' + value[tags.nameTag])
                if self.hasField(value, tags.valueTag):
                    enumValue = value[tags.valueTag]
                    if type(enumValue) is int:
                        strEnumValue = str(enumValue)
                    else:
                        strEnumValue = enumValue
                    self.file.write(' = ' + strEnumValue)
                self.file.write(',')
                if tags.descriptionTag in value and not value[tags.descriptionTag] is None:
                    self.file.write(' //!< ' + value[tags.descriptionTag])
                self.file.write('\n')

        self.file.write('    };\n')
        self.file.write('\n')

    def __addAlias(self, alias):
        name = alias[tags.aliasTag]
        type = self.getCppType(alias[tags.typeTag])
        if type is None:
            return

        self.file.write('    using ' + name + ' = ' + type + ';')
        if self.hasField(alias, tags.descriptionTag):
            self.file.write(' //!< ' + alias[tags.descriptionTag])

        self.file.write('\n')
        self.file.write('\n')

    def __addDomainObjects(self):
        if not self.hasField(self.yamlApi, tags.domainObjectsTag):
            return

        self.file.write('    // Domain objects\n\n')
        if not hasattr(self, 'domainObjects'):
            self.domainObjects = {}
        for domainObject in self.yamlApi[tags.domainObjectsTag]:
            if tags.structTag in domainObject:
                self.__addStruct(domainObject)
            elif tags.enumTag in domainObject:
                self.__addEnum(domainObject)
            elif tags.aliasTag in domainObject:
                self.__addAlias(domainObject)

    def __addMethod(self, method):
        if self.hasField(method, tags.typeTag):
            methodType = self.getCppType(method[tags.typeTag])
            if methodType is None:
                return
        else:
            methodType = 'void'

        if self.hasField(method, tags.descriptionTag):
            self.file.write('        /**\n')
            self.file.write('         * \\brief ' + method[tags.descriptionTag] + '\n')

            if self.hasField(method, tags.argumentsTag):
                for argument in method[tags.argumentsTag]:
                    if self.hasField(argument, tags.descriptionTag):
                        self.file.write('         * \\param ' + argument[tags.nameTag] + '    ' + argument[tags.descriptionTag] + '\n')

            self.file.write('         */\n')

        methodName = method[tags.nameTag]
        self.file.write('        virtual ' + methodType + ' ' + methodName + '(')
        if self.hasField(method, tags.argumentsTag):
            argNames = []
            for argument in method[tags.argumentsTag]:
                argName = argument[tags.nameTag];
                if argName in argNames:
                    print('Process: ', methodName, ' - argument \'', argName, '\' already present')
                    return

                argType = self.getCppType(argument[tags.typeTag])
                if argType is None:
                    return

                if len(argNames) != 0:
                    self.file.write(', ')
                self.file.write(argType + ' ' + argName)
                argNames.append(argName)

        self.file.write(')')
        if tags.constTag in method:
            isConst = method[tags.constTag]
        else:
            isConst = False

        if isConst:
            self.file.write(' const')

        self.file.write(' = 0;\n')

        if self.hasField(method, tags.descriptionTag):
            self.file.write('\n')

        self.process[methodName] = self.getUri(method, methodName)

    def __addProcess(self):
        if self.hasField(self.yamlApi, tags.moduleTag):
            return

        self.process = {}

        self.file.write('    // Process\n\n')
        service = self.yamlApi[tags.serviceTag]
        if self.hasField(service, tags.descriptionTag):
            self.file.write('    /**\n')
            self.file.write('     * \\brief ' + service[tags.descriptionTag] + '\n')
            self.file.write('     */\n')

        className = service[tags.nameTag]
        serviceName = className + 'Service'
        self.file.write('    class ' + className + ' {\n')
        self.file.write('    public:\n')

        self.file.write('        virtual ~' + className + '() = default;\n')

        if self.hasField(self.yamlApi, tags.processTag):
            self.file.write('\n')

            for method in self.yamlApi[tags.processTag]:
                self.__addMethod(method)

        self.file.write('    };\n\n')
        self.file.write(
            '    using ' + serviceName + ' = cho::osbase::application::IService<' + className + '>;\n')
        self.file.write('    using ' + serviceName + 'Ptr = std::shared_ptr<' + serviceName + '>;\n\n')
        self.file.write(
            '    ' + serviceName + 'Ptr makeStub(cho::osbase::application::TaskLoopPtr pTaskLoop = nullptr);\n')
        self.file.write('\n')

    def __addEvents(self):
        if self.hasField(self.yamlApi, tags.moduleTag):
            return

        if not self.hasField(self.yamlApi, tags.eventsTag):
            return

        self.file.write('    // Events\n\n')
        for event in self.yamlApi[tags.eventsTag]:
            if self.hasField(event, tags.descriptionTag):
                self.file.write('    /**\n')
                self.file.write('     * \\brief ' + event[tags.descriptionTag] + '\n')
                self.file.write('     */\n')

            self.file.write('    struct ' + event[tags.nameTag] + ' : cho::osbase::application::ServiceMsg<')
            if self.hasField(event, tags.typeTag):
                cppType = self.getCppType(event[tags.typeTag])
                if cppType is None:
                    return
            else:
                cppType = 'cho::osbase::application::NullMsg'

            self.file.write(cppType + '> {};\n')

        self.file.write('\n')

    def __addSerialization(self):
        if not hasattr(self, 'domainObjects'):
            return

        for domainObject in self.domainObjects:
            if self.domainObjects[domainObject] is None:
                continue

            type_declaration = domainObject
            for field in self.domainObjects[domainObject]:
                type_declaration += ', ' + field

            self.file.write('OS_KEY_SERIALIZE_STRUCT(' + type_declaration + ');\n')
            self.file.write('OS_SERIALIZE_STRUCT(' + type_declaration + ');\n')

    def __addEnumConverters(self):
        if not hasattr(self, 'domainObjects'):
            return

        if not self.hasField(self.yamlApi, tags.domainObjectsTag):
            return

        for domainObject in self.yamlApi[tags.domainObjectsTag]:
            if tags.enumTag in domainObject:
                enum = domainObject
                if self.hasField(enum, tags.valuesTag):
                    name = enum[tags.enumTag]
                    qualifiedName = self.namespace + "::" + name

                    self.file.write('\n/**\n')
                    self.file.write(' * \\brief Converter from ' + name + ' to std::string\n')
                    if self.hasField(enum, tags.descriptionTag):
                        self.file.write(' * ' + enum[tags.descriptionTag] + '\n')
                    self.file.write(' */\n')

                    self.file.write('template <>\n')
                    self.file.write('struct type_converter<std::string, ' + qualifiedName + '> {\n')
                    self.file.write('    static std::string convert(' + qualifiedName + ' value) {\n')

                    self.file.write('        static const std::map<' + qualifiedName + ', std::string> mapping {\n')
                    for value in enum[tags.valuesTag]:
                        element = value[tags.nameTag]
                        qualifiedElement = qualifiedName + "::" + element
                        self.file.write('            { ' + qualifiedElement + ', "' + element + '" },\n')
                    self.file.write('        };\n\n')

                    self.file.write('        const auto mappingIterator = mapping.find(value);\n')
                    self.file.write('        if (mappingIterator != mapping.end()) {\n')
                    self.file.write('            return mappingIterator->second;\n')
                    self.file.write('        };\n\n')

                    error = '"Unknown ' + name + ' value: " + std::to_string(static_cast<int>(value))'
                    self.file.write('        throw cho::osbase::application::ServiceException(' + error + ');\n')

                    self.file.write('    }\n')
                    self.file.write('};\n')

    def generate(self):
        self.__addHeader()
        self.__addIncludes()
        self.__addImports()
        self.addNamespace(True)
        self.__addConstants()
        self.__addDomainObjects()
        self.__addProcess()
        self.__addEvents()
        self.addNamespace(False)
        self.__addSerialization()
        self.__addEnumConverters()

